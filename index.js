const { Client, GatewayIntentBits, Collection, EmbedBuilder } = require('discord.js');
const fs = require('fs');
const path = require('path');
const config = require('./config.json');
const listManager = require('./utils/lists');
const antiRaid = require('./utils/antiraid');
const antiLink = require('./utils/antilink');
const Logger = require('./utils/logger');

// Cr√©er une nouvelle instance du client Discord
const client = new Client({
    intents: [
        GatewayIntentBits.Guilds,
        GatewayIntentBits.GuildMessages,
        GatewayIntentBits.MessageContent,
        GatewayIntentBits.GuildMembers
    ]
});

// Collection pour stocker les commandes
client.commands = new Collection();

// Collection pour stocker les derniers messages supprim√©s (par serveur)
client.snipedMessages = new Collection();

// Initialiser le syst√®me de logs
const logger = new Logger(client);

// Charger les commandes depuis le dossier commands
function loadCommands() {
    const commandsPath = path.join(__dirname, 'commands');
    
    if (!fs.existsSync(commandsPath)) {
        console.log('Dossier commands non trouv√©, cr√©ation...');
        fs.mkdirSync(commandsPath);
        return;
    }

    const commandFiles = fs.readdirSync(commandsPath).filter(file => file.endsWith('.js'));

    for (const file of commandFiles) {
        const filePath = path.join(commandsPath, file);
        const command = require(filePath);
        
        if ('name' in command && 'execute' in command) {
            client.commands.set(command.name, command);
            console.log(`‚úÖ Commande charg√©e: ${command.name}`);
        } else {
            console.log(`‚ùå Commande invalide dans ${filePath}`);
        }
    }
}

// Fonction pour v√©rifier si un utilisateur est owner
async function isOwner(userId) {
    return userId === config.ownerID || await listManager.isOwner(userId);
}

// Gestionnaire d'√©v√©nements pour les messages
client.on('messageCreate', async message => {
    if (message.author.bot) return;
    
    // V√©rifier si le bot est mentionn√©
    if (message.mentions.users.has(client.user.id)) {
        return message.reply(`Hey ${message.author}, Mon Prefix est [${config.prefix}] ! H√©site pas √† faire ${config.prefix}helpall pour toutes les commandes !`);
    }
    
    if (!message.content.startsWith(config.prefix)) {
        // V√©rifier l'antilink/antihere/antieveryone
        try {
            await antiLink.processMessage(message, client);
        } catch (error) {
            console.error('Erreur lors du traitement antilink:', error);
        }
        return;
    }

    const args = message.content.slice(config.prefix.length).trim().split(/ +/);
    const commandName = args.shift().toLowerCase();

    const command = client.commands.get(commandName) || 
                   client.commands.find(cmd => cmd.aliases && cmd.aliases.includes(commandName));

    if (!command) return;

    try {
        // V√©rifier si l'utilisateur est blacklist√©
        const isBlacklisted = await listManager.isBlacklisted(message.author.id);
        if (isBlacklisted) {
            return message.reply('üö´ Vous √™tes blacklist√© et ne pouvez pas utiliser les commandes du bot.');
        }

        // V√©rifier si l'utilisateur est whitelist√© (si la whitelist est activ√©e)
        const whitelist = await listManager.getWhitelist();
        if (whitelist.length > 0) {
            const isWhitelisted = await listManager.isWhitelisted(message.author.id);
            if (!isWhitelisted) {
                return message.reply('‚ùå Vous n\'√™tes pas autoris√© √† utiliser les commandes du bot.');
            }
        }

        // V√©rifier les permissions
        if (command.permissions) {
            const authorPerms = message.channel.permissionsFor(message.author);
            if (!authorPerms || !command.permissions.every(perm => authorPerms.has(perm))) {
                return message.reply('‚ùå Vous n\'avez pas les permissions n√©cessaires pour utiliser cette commande !');
            }
        }

        // V√©rifier si la commande est owner-only
        if (command.ownerOnly) {
            const userIsOwner = await isOwner(message.author.id);
            if (!userIsOwner) {
                return message.reply('‚ùå Cette commande est r√©serv√©e aux propri√©taires du bot !');
            }
        }

        // Logger la commande utilis√©e
        await logger.logCommand(message.guild, message.author, commandName, message.channel, args);

        // Ex√©cuter la commande
        await command.execute(message, args, client);
    } catch (error) {
        console.error(error);
        message.reply('‚ùå Une erreur s\'est produite lors de l\'ex√©cution de cette commande !');
    }
});

// √âv√©nement pour g√©rer les nouveaux membres (blacklist automatique + antiraid)
client.on('guildMemberAdd', async member => {
    // Logger l'arriv√©e du membre
    await logger.logMember(member.guild, 'Membre Rejoint', member, 'Nouveau membre sur le serveur');

    // V√©rifier si l'utilisateur est blacklist√©
    const isBlacklisted = await listManager.isBlacklisted(member.user.id);
    if (isBlacklisted) {
        try {
            await member.ban({ reason: 'Utilisateur blacklist√© automatiquement' });
            console.log(`üö´ Utilisateur blacklist√© ${member.user.tag} banni automatiquement de ${member.guild.name}`);
            await logger.logModeration(member.guild, 'Bannissement Automatique', 'Syst√®me', member.user, 'Utilisateur blacklist√©');
        } catch (error) {
            console.error(`Erreur lors du bannissement automatique de ${member.user.tag}:`, error);
        }
    }

    // V√©rifier avec le syst√®me d'antiraid
    try {
        await antiRaid.checkNewMember(member, client);
    } catch (error) {
        console.error('Erreur lors de la v√©rification antiraid:', error);
    }
    
    // Envoyer le message de bienvenue si configur√©
    try {
        const database = require('./utils/database');
        const welcomeConfig = await database.getWelcomeConfig(member.guild.id);
        
        if (welcomeConfig) {
            const channel = member.guild.channels.cache.get(welcomeConfig.channel_id);
            if (channel) {
                const memberCount = member.guild.memberCount;
                const guildName = member.guild.name;
                
                const welcomeEmbed = new EmbedBuilder()
                    .setColor(config.embedColor)
                    .setTitle('üåü Bienvenue !')
                    .setDescription(`> **Bienvenue ${member} sur \`${guildName}\` üåü !**\n> **Nous sommes d√©sormais ${memberCount} sur le serveur ! üåü**\n> **\`/Ginka\` en statut pour avoir la perm image !**`)
                    .setThumbnail(member.user.displayAvatarURL({ dynamic: true }))
                    .setTimestamp()
                    .setFooter({ text: '¬© Powered by y3t2', iconURL: client.user.displayAvatarURL() });

                await channel.send({ embeds: [welcomeEmbed] });
            }
        }
    } catch (error) {
        console.error('Erreur lors de l\'envoi du message de bienvenue:', error);
    }
    
    // Mettre √† jour le RPC
    updateActivity();
});

// √âv√©nement pour g√©rer les d√©parts de membres
client.on('guildMemberRemove', async member => {
    await logger.logMember(member.guild, 'Membre Parti', member, 'Membre a quitt√© le serveur');
    
    // Envoyer le message de d√©part si configur√©
    try {
        const database = require('./utils/database');
        const leaveConfig = await database.getLeaveConfig(member.guild.id);
        
        if (leaveConfig) {
            const channel = member.guild.channels.cache.get(leaveConfig.channel_id);
            if (channel) {
                const memberCount = member.guild.memberCount;
                
                const leaveEmbed = new EmbedBuilder()
                    .setColor(config.embedColor)
                    .setTitle('üëã Au revoir !')
                    .setDescription(`> **Au revoir ${member} ! Nous sommes d√©sormais ${memberCount} sur le serveur ! üåü**`)
                    .setThumbnail(member.user.displayAvatarURL({ dynamic: true }))
                    .setTimestamp()
                    .setFooter({ text: '¬© Powered by y3t2', iconURL: client.user.displayAvatarURL() });

                await channel.send({ embeds: [leaveEmbed] });
            }
        }
    } catch (error) {
        console.error('Erreur lors de l\'envoi du message de d√©part:', error);
    }
    
    // Mettre √† jour le RPC
    updateActivity();
});

// √âv√©nement pour g√©rer les modifications de messages
client.on('messageUpdate', async (oldMessage, newMessage) => {
    if (oldMessage.author.bot) return;
    if (oldMessage.content === newMessage.content) return;

    await logger.logMessage(newMessage.guild, 'Message Modifi√©', newMessage, 
        `**Ancien contenu:** ${oldMessage.content}\n**Nouveau contenu:** ${newMessage.content}`);
});

// √âv√©nement pour g√©rer les suppressions de messages
client.on('messageDelete', async message => {
    if (message.author?.bot) return;

    // Stocker le message supprim√© pour la commande snipe
    client.snipedMessages.set(message.guild.id, {
        content: message.content,
        author: message.author,
        channel: message.channel,
        timestamp: Date.now(),
        attachments: message.attachments.size > 0 ? Array.from(message.attachments.values()) : []
    });

    await logger.logMessage(message.guild, 'Message Supprim√©', message, 'Message supprim√©');
});

// √âv√©nement pour g√©rer les cr√©ations de r√¥les
client.on('roleCreate', async role => {
    await logger.logRole(role.guild, 'R√¥le Cr√©√©', role, 'Syst√®me', 'Nouveau r√¥le cr√©√©');
});

// √âv√©nement pour g√©rer les suppressions de r√¥les
client.on('roleDelete', async role => {
    await logger.logRole(role.guild, 'R√¥le Supprim√©', role, 'Syst√®me', 'R√¥le supprim√©');
});

// √âv√©nement pour g√©rer les cr√©ations de canaux
client.on('channelCreate', async channel => {
    if (channel.type === 0) { // Text channel only
        await logger.logChannel(channel.guild, 'Canal Cr√©√©', channel, 'Syst√®me', 'Nouveau canal cr√©√©');
    }
});

// √âv√©nement pour g√©rer les suppressions de canaux
client.on('channelDelete', async channel => {
    if (channel.type === 0) { // Text channel only
        await logger.logChannel(channel.guild, 'Canal Supprim√©', channel, 'Syst√®me', 'Canal supprim√©');
    }
});

// √âv√©nement pour g√©rer les activit√©s vocales
client.on('voiceStateUpdate', async (oldState, newState) => {
    const member = newState.member;
    
    // Membre rejoint un canal vocal
    if (!oldState.channel && newState.channel) {
        await logger.logVoice(newState.guild, 'Rejoint Canal Vocal', member, newState.channel, 
            `Canal: ${newState.channel.name}`);
    }
    
    // Membre quitte un canal vocal
    if (oldState.channel && !newState.channel) {
        await logger.logVoice(oldState.guild, 'Quitte Canal Vocal', member, oldState.channel, 
            `Canal: ${oldState.channel.name}`);
    }
    
    // Membre change de canal vocal
    if (oldState.channel && newState.channel && oldState.channel.id !== newState.channel.id) {
        await logger.logVoice(newState.guild, 'Change Canal Vocal', member, newState.channel, 
            `De: ${oldState.channel.name} ‚Üí Vers: ${newState.channel.name}`);
    }
});

// Fonction pour calculer le nombre total de membres
function getTotalMembers() {
    let totalMembers = 0;
    client.guilds.cache.forEach(guild => {
        totalMembers += guild.memberCount;
    });
    return totalMembers;
}

// Fonction pour mettre √† jour l'activit√© RPC
function updateActivity() {
    try {
        const totalMembers = getTotalMembers();
        console.log(`üîÑ Mise √† jour RPC: ${totalMembers} membres`);
        
        client.user.setActivity(`${totalMembers.toLocaleString()} membres`, { 
            type: 3 // WATCHING
        });
        
        console.log(`‚úÖ RPC mis √† jour: "${totalMembers.toLocaleString()} membres"`);
    } catch (error) {
        console.error('‚ùå Erreur lors de la mise √† jour du RPC:', error);
    }
}

// √âv√©nement ready
client.on('ready', async () => {
    console.log(`ü§ñ Bot connect√© en tant que ${client.user.tag}`);
    console.log(`üìä Servant ${client.guilds.cache.size} serveurs`);
    console.log(`üë• Servant ${client.users.cache.size} utilisateurs`);
    
    // Migrer les anciens fichiers JSON vers SQLite si n√©cessaire
    await listManager.migrateFromJSON();
    
    // Afficher les informations sur les listes
    const stats = await listManager.getStats();
    console.log(`üö´ Blacklist: ${stats.blacklist_count} utilisateur(s)`);
    console.log(`‚úÖ Whitelist: ${stats.whitelist_count} utilisateur(s)`);
    console.log(`üëë Owners: ${stats.owners_count} propri√©taire(s)`);
    
    // Afficher les informations sur l'antiraid
    console.log(`üõ°Ô∏è Syst√®me Antiraid: Actif`);
    
    // Afficher les informations sur l'antilink
    console.log(`üîó Syst√®me Antilink: Actif`);
    
    // D√©finir l'activit√© RPC avec le nombre de membres
    updateActivity();
    
    // Mettre √† jour l'activit√© toutes les 5 minutes
    setInterval(updateActivity, 5 * 60 * 1000);
});

// Gestion des erreurs
client.on('error', error => {
    console.error('Erreur Discord.js:', error);
});

process.on('unhandledRejection', error => {
    console.error('Promesse rejet√©e non g√©r√©e:', error);
});

// Gestion de la fermeture propre
process.on('SIGINT', () => {
    console.log('\nüîÑ Arr√™t du bot...');
    const database = require('./utils/database');
    database.close();
    process.exit(0);
});

// Charger les commandes et se connecter
loadCommands();
client.login(config.token); 