const { EmbedBuilder, PermissionFlagsBits } = require('discord.js');
const config = require('../config.json');
const antiLink = require('../utils/antilink');

module.exports = {
    name: 'antilink',
    aliases: ['al', 'antihere', 'antieveryone'],
    description: 'G√®re le syst√®me d\'antilink, antihere et antieveryone',
    usage: 'antilink <type> <on/off/status/action/whitelist> [param√®tres]',
    category: 'Administration',
    permissions: [PermissionFlagsBits.ManageMessages],
    async execute(message, args, client) {
        if (!args.length) {
            return this.showHelp(message);
        }

        const type = args[0].toLowerCase();
        const action = args[1]?.toLowerCase();

        switch (type) {
            case 'link':
            case 'antilink':
                await this.handleAntilink(message, action, args.slice(2));
                break;
            case 'here':
            case 'antihere':
                await this.handleAntihere(message, action, args.slice(2));
                break;
            case 'everyone':
            case 'antieveryone':
                await this.handleAntieveryone(message, action, args.slice(2));
                break;
            case 'status':
                await this.showStatus(message);
                break;
            case 'action':
                await this.setAction(message, action);
                break;
            case 'whitelist':
                await this.handleWhitelist(message, action, args.slice(2));
                break;
            default:
                message.reply('‚ùå Type invalide. Utilisez: `link`, `here`, `everyone`, `status`, `action`, `whitelist`');
        }
    },

    async handleAntilink(message, action, params) {
        const guildId = message.guild.id;

        switch (action) {
            case 'on':
                antiLink.setProtection(guildId, 'antilink', true);
                await this.sendSuccess(message, 'Antilink activ√©');
                break;
            case 'off':
                antiLink.setProtection(guildId, 'antilink', false);
                await this.sendSuccess(message, 'Antilink d√©sactiv√©');
                break;
            default:
                message.reply('‚ùå Action invalide. Utilisez: `on` ou `off`');
        }
    },

    async handleAntihere(message, action, params) {
        const guildId = message.guild.id;

        switch (action) {
            case 'on':
                antiLink.setProtection(guildId, 'antihere', true);
                await this.sendSuccess(message, 'Antihere activ√©');
                break;
            case 'off':
                antiLink.setProtection(guildId, 'antihere', false);
                await this.sendSuccess(message, 'Antihere d√©sactiv√©');
                break;
            default:
                message.reply('‚ùå Action invalide. Utilisez: `on` ou `off`');
        }
    },

    async handleAntieveryone(message, action, params) {
        const guildId = message.guild.id;

        switch (action) {
            case 'on':
                antiLink.setProtection(guildId, 'antieveryone', true);
                await this.sendSuccess(message, 'Antieveryone activ√©');
                break;
            case 'off':
                antiLink.setProtection(guildId, 'antieveryone', false);
                await this.sendSuccess(message, 'Antieveryone d√©sactiv√©');
                break;
            default:
                message.reply('‚ùå Action invalide. Utilisez: `on` ou `off`');
        }
    },

    async setAction(message, action) {
        const guildId = message.guild.id;
        const validActions = ['delete', 'warn', 'kick', 'ban'];

        if (!validActions.includes(action)) {
            return message.reply(`‚ùå Action invalide. Utilisez: ${validActions.join(', ')}`);
        }

        antiLink.setAction(guildId, action);
        await this.sendSuccess(message, `Action d√©finie sur: ${action}`);
    },

    async handleWhitelist(message, action, params) {
        const guildId = message.guild.id;

        switch (action) {
            case 'channel':
            case 'channels':
                await this.handleChannelWhitelist(message, params);
                break;
            case 'role':
            case 'roles':
                await this.handleRoleWhitelist(message, params);
                break;
            case 'user':
            case 'users':
                await this.handleUserWhitelist(message, params);
                break;
            case 'list':
                await this.showWhitelist(message);
                break;
            default:
                message.reply('‚ùå Type de whitelist invalide. Utilisez: `channel`, `role`, `user`, `list`');
        }
    },

    async handleChannelWhitelist(message, params) {
        const guildId = message.guild.id;
        const subAction = params[0]?.toLowerCase();
        const channelMention = params[1];

        if (!subAction || !channelMention) {
            return message.reply('‚ùå Usage: `antilink whitelist channel <add/remove> #canal`');
        }

        const channel = message.mentions.channels.first();
        if (!channel) {
            return message.reply('‚ùå Canal invalide. Mentionnez un canal avec #');
        }

        const add = subAction === 'add';
        antiLink.toggleWhitelist(guildId, 'Channels', channel.id, add);
        
        await this.sendSuccess(message, `Canal ${add ? 'ajout√© √†' : 'retir√© de'} la whitelist: ${channel.name}`);
    },

    async handleRoleWhitelist(message, params) {
        const guildId = message.guild.id;
        const subAction = params[0]?.toLowerCase();
        const roleMention = params[1];

        if (!subAction || !roleMention) {
            return message.reply('‚ùå Usage: `antilink whitelist role <add/remove> @r√¥le`');
        }

        const role = message.mentions.roles.first();
        if (!role) {
            return message.reply('‚ùå R√¥le invalide. Mentionnez un r√¥le avec @');
        }

        const add = subAction === 'add';
        antiLink.toggleWhitelist(guildId, 'Roles', role.id, add);
        
        await this.sendSuccess(message, `R√¥le ${add ? 'ajout√© √†' : 'retir√© de'} la whitelist: ${role.name}`);
    },

    async handleUserWhitelist(message, params) {
        const guildId = message.guild.id;
        const subAction = params[0]?.toLowerCase();
        const userMention = params[1];

        if (!subAction || !userMention) {
            return message.reply('‚ùå Usage: `antilink whitelist user <add/remove> @utilisateur`');
        }

        const user = message.mentions.users.first();
        if (!user) {
            return message.reply('‚ùå Utilisateur invalide. Mentionnez un utilisateur avec @');
        }

        const add = subAction === 'add';
        antiLink.toggleWhitelist(guildId, 'Users', user.id, add);
        
        await this.sendSuccess(message, `Utilisateur ${add ? 'ajout√© √†' : 'retir√© de'} la whitelist: ${user.tag}`);
    },

    async showWhitelist(message) {
        const guildId = message.guild.id;
        const settings = antiLink.getSettings(guildId);

        const embed = new EmbedBuilder()
            .setColor(config.embedColor)
            .setTitle('üìã Whitelist Anti-Protection')
            .addFields(
                { 
                    name: 'üì∫ Canaux Whitelist√©s', 
                    value: settings.whitelistChannels.length > 0 
                        ? settings.whitelistChannels.map(id => `<#${id}>`).join(', ')
                        : 'Aucun canal whitelist√©',
                    inline: false 
                },
                { 
                    name: 'üé≠ R√¥les Whitelist√©s', 
                    value: settings.whitelistRoles.length > 0 
                        ? settings.whitelistRoles.map(id => `<@&${id}>`).join(', ')
                        : 'Aucun r√¥le whitelist√©',
                    inline: false 
                },
                { 
                    name: 'üë§ Utilisateurs Whitelist√©s', 
                    value: settings.whitelistUsers.length > 0 
                        ? settings.whitelistUsers.map(id => `<@${id}>`).join(', ')
                        : 'Aucun utilisateur whitelist√©',
                    inline: false 
                }
            )
            .setTimestamp()
            .setFooter({ text: `Demand√© par ${message.author.tag}`, iconURL: message.author.displayAvatarURL() });

        message.reply({ embeds: [embed] });
    },

    async showStatus(message) {
        const guildId = message.guild.id;
        const stats = antiLink.getStats(guildId);

        const embed = new EmbedBuilder()
            .setColor(config.embedColor)
            .setTitle('üõ°Ô∏è Statut Anti-Protection')
            .addFields(
                { 
                    name: 'üîó Antilink', 
                    value: stats.antilink ? '‚úÖ Activ√©' : '‚ùå D√©sactiv√©', 
                    inline: true 
                },
                { 
                    name: 'üìç Antihere', 
                    value: stats.antihere ? '‚úÖ Activ√©' : '‚ùå D√©sactiv√©', 
                    inline: true 
                },
                { 
                    name: 'üë• Antieveryone', 
                    value: stats.antieveryone ? '‚úÖ Activ√©' : '‚ùå D√©sactiv√©', 
                    inline: true 
                },
                { 
                    name: '‚ö° Action', 
                    value: this.getActionText(stats.action), 
                    inline: true 
                },
                { 
                    name: 'üìã Whitelist', 
                    value: `Canaux: ${stats.whitelistChannels}\nR√¥les: ${stats.whitelistRoles}\nUtilisateurs: ${stats.whitelistUsers}`, 
                    inline: true 
                }
            )
            .addFields(
                { 
                    name: 'üí° Actions disponibles', 
                    value: '‚Ä¢ `delete` - Supprimer le message\n‚Ä¢ `warn` - Avertir l\'utilisateur\n‚Ä¢ `kick` - Expulser l\'utilisateur\n‚Ä¢ `ban` - Bannir l\'utilisateur', 
                    inline: false 
                }
            )
            .setTimestamp()
            .setFooter({ text: `Demand√© par ${message.author.tag}`, iconURL: message.author.displayAvatarURL() });

        message.reply({ embeds: [embed] });
    },

    async showHelp(message) {
        const embed = new EmbedBuilder()
            .setColor(config.embedColor)
            .setTitle('üõ°Ô∏è Aide Anti-Protection')
            .setDescription('Syst√®me de protection contre les liens, @here et @everyone')
            .addFields(
                { 
                    name: 'üîó Antilink', 
                    value: '`antilink link on/off` - Activer/d√©sactiver la protection des liens', 
                    inline: false 
                },
                { 
                    name: 'üìç Antihere', 
                    value: '`antilink here on/off` - Activer/d√©sactiver la protection @here', 
                    inline: false 
                },
                { 
                    name: 'üë• Antieveryone', 
                    value: '`antilink everyone on/off` - Activer/d√©sactiver la protection @everyone', 
                    inline: false 
                },
                { 
                    name: '‚ö° Action', 
                    value: '`antilink action <delete/warn/kick/ban>` - D√©finir l\'action', 
                    inline: false 
                },
                { 
                    name: 'üìã Whitelist', 
                    value: '`antilink whitelist <channel/role/user> <add/remove> @mention`', 
                    inline: false 
                },
                { 
                    name: 'üìä Statut', 
                    value: '`antilink status` - Voir le statut complet', 
                    inline: false 
                }
            )
            .setTimestamp()
            .setFooter({ text: `Demand√© par ${message.author.tag}`, iconURL: message.author.displayAvatarURL() });

        message.reply({ embeds: [embed] });
    },

    async sendSuccess(message, text) {
        const embed = new EmbedBuilder()
            .setColor('#00ff00')
            .setTitle('‚úÖ Succ√®s')
            .setDescription(text)
            .setTimestamp()
            .setFooter({ text: `Par ${message.author.tag}`, iconURL: message.author.displayAvatarURL() });

        message.reply({ embeds: [embed] });
    },

    getActionText(action) {
        const actions = {
            'delete': 'üóëÔ∏è Suppression du message',
            'warn': '‚ö†Ô∏è Avertissement',
            'kick': 'üë¢ Expulsion',
            'ban': 'üî® Bannissement'
        };
        return actions[action] || 'üóëÔ∏è Suppression du message';
    }
}; 